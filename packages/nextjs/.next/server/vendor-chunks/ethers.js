"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethers";
exports.ids = ["vendor-chunks/ethers"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethers/lib.esm/_version.js":
/*!*************************************************!*\
  !*** ./node_modules/ethers/lib.esm/_version.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */\n/**\n *  The current version of Ethers.\n */\nconst version = \"6.15.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9zbmFwcC9wYWNrYWdlcy9uZXh0anMvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL192ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIERvIE5PVCBtb2RpZnkgdGhpcyBmaWxlOyBzZWUgL3NyYy50cy9fYWRtaW4vdXBkYXRlLXZlcnNpb24udHMgKi9cbi8qKlxuICogIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgRXRoZXJzLlxuICovXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiNi4xNS4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/data.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/data.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   dataLength: () => (/* binding */ dataLength),\n/* harmony export */   dataSlice: () => (/* binding */ dataSlice),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getBytesCopy: () => (/* binding */ getBytesCopy),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   stripZerosLeft: () => (/* binding */ stripZerosLeft),\n/* harmony export */   zeroPadBytes: () => (/* binding */ zeroPadBytes),\n/* harmony export */   zeroPadValue: () => (/* binding */ zeroPadValue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\n\nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof (value) === \"string\" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nfunction getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nfunction getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nfunction isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof (length) === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && (value.length % 2) !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nfunction isBytesLike(value) {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nfunction hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nfunction concat(datas) {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nfunction dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nfunction dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nfunction stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) {\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    }\n    else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nfunction zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nfunction zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n}\n//# sourceMappingURL=data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9zbmFwcC9wYWNrYWdlcy9uZXh0anMvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2RhdGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgU29tZSBkYXRhIGhlbHBlcnMuXG4gKlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOkRhdGEgSGVscGVycyAgW2Fib3V0LWRhdGFdXG4gKi9cbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmZ1bmN0aW9uIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgY29weSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubWF0Y2goL14weCg/OlswLTlhLWZdWzAtOWEtZl0pKiQvaSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMik7XG4gICAgICAgIGxldCBvZmZzZXQgPSAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgMiksIDE2KTtcbiAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQnl0ZXNMaWtlIHZhbHVlXCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKipcbiAqICBHZXQgYSB0eXBlZCBVaW50OEFycmF5IGZvciAlJXZhbHVlJSUuIElmIGFscmVhZHkgYSBVaW50OEFycmF5XG4gKiAgdGhlIG9yaWdpbmFsICUldmFsdWUlJSBpcyByZXR1cm5lZDsgaWYgYSBjb3B5IGlzIHJlcXVpcmVkIHVzZVxuICogIFtbZ2V0Qnl0ZXNDb3B5XV0uXG4gKlxuICogIEBzZWU6IGdldEJ5dGVzQ29weVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qnl0ZXModmFsdWUsIG5hbWUpIHtcbiAgICByZXR1cm4gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCBmYWxzZSk7XG59XG4vKipcbiAqICBHZXQgYSB0eXBlZCBVaW50OEFycmF5IGZvciAlJXZhbHVlJSUsIGNyZWF0aW5nIGEgY29weSBpZiBuZWNlc3NhcnlcbiAqICB0byBwcmV2ZW50IGFueSBtb2RpZmljYXRpb25zIG9mIHRoZSByZXR1cm5lZCB2YWx1ZSBmcm9tIGJlaW5nXG4gKiAgcmVmbGVjdGVkIGVsc2V3aGVyZS5cbiAqXG4gKiAgQHNlZTogZ2V0Qnl0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ5dGVzQ29weSh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIHRydWUpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIFtbSGV4U3RyaW5nXV0uXG4gKlxuICogIElmICUlbGVuZ3RoJSUgaXMgYGB0cnVlYGAgb3IgYSAvL251bWJlci8vLCBpdCBhbHNvIGNoZWNrcyB0aGF0XG4gKiAgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVsZW5ndGglJSAoaWYgYSAvL251bWJlci8vKVxuICogIGJ5dGVzIG9mIGRhdGEgKGUuZy4gYGAweDEyMzRgYCBpcyAyIGJ5dGVzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChsZW5ndGgpID09PSBcIm51bWJlclwiICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoID09PSB0cnVlICYmICh2YWx1ZS5sZW5ndGggJSAyKSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIHJlcHJlc2VudGF0aW9uIG9mIGFyYml0cmFyeVxuICogIGRhdGEgKGkuZS4gYSB2YWxpZCBbW0RhdGFIZXhTdHJpbmddXSBvciBhIFVpbnQ4QXJyYXkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlc0xpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzSGV4U3RyaW5nKHZhbHVlLCB0cnVlKSB8fCAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSk7XG59XG5jb25zdCBIZXhDaGFyYWN0ZXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gcmVwcmVzZW50YXRpb24gb2YgJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhsaWZ5KGRhdGEpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2ID0gYnl0ZXNbaV07XG4gICAgICAgIHJlc3VsdCArPSBIZXhDaGFyYWN0ZXJzWyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhDaGFyYWN0ZXJzW3YgJiAweDBmXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSBieSBjb25jYXRlbmF0aW5nIGFsbCB2YWx1ZXNcbiAqICB3aXRoaW4gJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoZGF0YXMpIHtcbiAgICByZXR1cm4gXCIweFwiICsgZGF0YXMubWFwKChkKSA9PiBoZXhsaWZ5KGQpLnN1YnN0cmluZygyKSkuam9pbihcIlwiKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIGxlbmd0aCBvZiAlJWRhdGElJSwgaW4gYnl0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRhTGVuZ3RoKGRhdGEpIHtcbiAgICBpZiAoaXNIZXhTdHJpbmcoZGF0YSwgdHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuIChkYXRhLmxlbmd0aCAtIDIpIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJ5dGVzKGRhdGEpLmxlbmd0aDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSBieSBzbGljaW5nICUlZGF0YSUlIGZyb20gdGhlICUlc3RhcnQlJVxuICogIG9mZnNldCB0byB0aGUgJSVlbmQlJSBvZmZzZXQuXG4gKlxuICogIEJ5IGRlZmF1bHQgJSVzdGFydCUlIGlzIDAgYW5kICUlZW5kJSUgaXMgdGhlIGxlbmd0aCBvZiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFTbGljZShkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICBpZiAoZW5kICE9IG51bGwgJiYgZW5kID4gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjYW5ub3Qgc2xpY2UgYmV5b25kIGRhdGEgYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBieXRlcy5sZW5ndGgsIG9mZnNldDogZW5kXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShieXRlcy5zbGljZSgoc3RhcnQgPT0gbnVsbCkgPyAwIDogc3RhcnQsIChlbmQgPT0gbnVsbCkgPyBieXRlcy5sZW5ndGggOiBlbmQpKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gcmVzdWx0IGJ5IHN0cmlwcGluZyBhbGwgKipsZWFkaW5nKipcbiAqKiB6ZXJvIGJ5dGVzIGZyb20gJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFplcm9zTGVmdChkYXRhKSB7XG4gICAgbGV0IGJ5dGVzID0gaGV4bGlmeShkYXRhKS5zdWJzdHJpbmcoMik7XG4gICAgd2hpbGUgKGJ5dGVzLnN0YXJ0c1dpdGgoXCIwMFwiKSkge1xuICAgICAgICBieXRlcyA9IGJ5dGVzLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGJ5dGVzO1xufVxuZnVuY3Rpb24gemVyb1BhZChkYXRhLCBsZW5ndGgsIGxlZnQpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGFzc2VydChsZW5ndGggPj0gYnl0ZXMubGVuZ3RoLCBcInBhZGRpbmcgZXhjZWVkcyBkYXRhIGxlbmd0aFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgYnVmZmVyOiBuZXcgVWludDhBcnJheShieXRlcyksXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICBvZmZzZXQ6IGxlbmd0aCArIDFcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHJlc3VsdC5maWxsKDApO1xuICAgIGlmIChsZWZ0KSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIGxlbmd0aCAtIGJ5dGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuc2V0KGJ5dGVzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKmxlZnQqKlxuICogIHRvICUlbGVuZ3RoJSUgYnl0ZXMuXG4gKlxuICogIElmICUlZGF0YSUlIGFscmVhZHkgZXhjZWVkcyAlJWxlbmd0aCUlLCBhIFtbQnVmZmVyT3ZlcnJ1bkVycm9yXV0gaXNcbiAqICB0aHJvd24uXG4gKlxuICogIFRoaXMgcGFkcyBkYXRhIHRoZSBzYW1lIGFzICoqdmFsdWVzKiogYXJlIGluIFNvbGlkaXR5XG4gKiAgKGUuZy4gYGB1aW50MTI4YGApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZFZhbHVlKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgdHJ1ZSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIG9mICUlZGF0YSUlIHBhZGRlZCBvbiB0aGUgKipyaWdodCoqXG4gKiAgdG8gJSVsZW5ndGglJSBieXRlcy5cbiAqXG4gKiAgSWYgJSVkYXRhJSUgYWxyZWFkeSBleGNlZWRzICUlbGVuZ3RoJSUsIGEgW1tCdWZmZXJPdmVycnVuRXJyb3JdXSBpc1xuICogIHRocm93bi5cbiAqXG4gKiAgVGhpcyBwYWRzIGRhdGEgdGhlIHNhbWUgYXMgKipieXRlcyoqIGFyZSBpbiBTb2xpZGl0eVxuICogIChlLmcuIGBgYnl0ZXMxNmBgKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHplcm9QYWRCeXRlcyhkYXRhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gemVyb1BhZChkYXRhLCBsZW5ndGgsIGZhbHNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/errors.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertArgument: () => (/* binding */ assertArgument),\n/* harmony export */   assertArgumentCount: () => (/* binding */ assertArgumentCount),\n/* harmony export */   assertNormalize: () => (/* binding */ assertNormalize),\n/* harmony export */   assertPrivate: () => (/* binding */ assertPrivate),\n/* harmony export */   isCallException: () => (/* binding */ isCallException),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   makeError: () => (/* binding */ makeError)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"(ssr)/./node_modules/ethers/lib.esm/_version.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\n\n\nfunction stringify(value, seen) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (seen == null) {\n        seen = new Set();\n    }\n    if (typeof (value) === \"object\") {\n        if (seen.has(value)) {\n            return \"[Circular]\";\n        }\n        seen.add(value);\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map((v) => stringify(v, seen))).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\n        return stringify(value.toJSON(), seen);\n    }\n    switch (typeof (value)) {\n        case \"boolean\":\n        case \"number\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(\", \") + \" }\";\n        }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nfunction isError(error, code) {\n    return (error && error.code === code);\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nfunction isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */\nfunction makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for (const key in info) {\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = (info[key]);\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n                //                } catch (error: any) {\n                //                console.log(\"MMM\", error.message);\n                //                    details.push(key + \"=[could not serialize object]\");\n                //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${_version_js__WEBPACK_IMPORTED_MODULE_0__.version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, { code });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, { shortMessage });\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nfunction assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nfunction assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\nfunction assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */\n            if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n            /* c8 ignore stop */\n        }\n        accum.push(form);\n    }\n    catch (error) { }\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nfunction assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nfunction assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7QUFDVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUIsbUJBQW1CLElBQUksMEJBQTBCLG1CQUFtQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxnQkFBZ0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEMsZ0NBQWdDLGdEQUFPLENBQUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFnQixVQUFVLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdFQUFnQixVQUFVLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpREFBaUQsOEJBQThCO0FBQy9FO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHlEQUF5RDtBQUN6RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxNQUFNLE9BQU87QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9zbmFwcC9wYWNrYWdlcy9uZXh0anMvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2Vycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBbGwgZXJyb3JzIGluIGV0aGVycyBpbmNsdWRlIHByb3BlcnRpZXMgdG8gZW5zdXJlIHRoZXkgYXJlIGJvdGhcbiAqICBodW1hbi1yZWFkYWJsZSAoaS5lLiBgYC5tZXNzYWdlYGApIGFuZCBtYWNoaW5lLXJlYWRhYmxlIChpLmUuIGBgLmNvZGVgYCkuXG4gKlxuICogIFRoZSBbW2lzRXJyb3JdXSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjaGVjayB0aGUgZXJyb3IgYGBjb2RlYGAgYW5kXG4gKiAgcHJvdmlkZSBhIHR5cGUgZ3VhcmQgZm9yIHRoZSBwcm9wZXJ0aWVzIHByZXNlbnQgb24gdGhhdCBlcnJvciBpbnRlcmZhY2UuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3V0aWxzL2Vycm9yczpFcnJvcnMgIFthYm91dC1lcnJvcnNdXG4gKi9cbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3ZlcnNpb24uanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHNlZW4pIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmIChzZWVuID09IG51bGwpIHtcbiAgICAgICAgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIltDaXJjdWxhcl1cIjtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLmFkZCh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJbIFwiICsgKHZhbHVlLm1hcCgodikgPT4gc3RyaW5naWZ5KHYsIHNlZW4pKSkuam9pbihcIiwgXCIpICsgXCIgXVwiO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhFWFt2YWx1ZVtpXSAmIDB4Zl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiAodmFsdWUudG9KU09OKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkodmFsdWUudG9KU09OKCksIHNlZW4pO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIFwieyBcIiArIGtleXMubWFwKChrKSA9PiBgJHtzdHJpbmdpZnkoaywgc2Vlbil9OiAke3N0cmluZ2lmeSh2YWx1ZVtrXSwgc2Vlbil9YCkuam9pbihcIiwgXCIpICsgXCIgfVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgWyBDT1VMRCBOT1QgU0VSSUFMSVpFIF1gO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmIHRoZSAlJWVycm9yJSUgbWF0Y2hlcyBhbiBlcnJvciB0aHJvd24gYnkgZXRoZXJzXG4gKiAgdGhhdCBtYXRjaGVzIHRoZSBlcnJvciAlJWNvZGUlJS5cbiAqXG4gKiAgSW4gVHlwZVNjcmlwdCBlbnZpcm9ubWVudHMsIHRoaXMgY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhhdCAlJWVycm9yJSVcbiAqICBtYXRjaGVzIGFuIEV0aGVyc0Vycm9yIHR5cGUsIHdoaWNoIG1lYW5zIHRoZSBleHBlY3RlZCBwcm9wZXJ0aWVzIHdpbGxcbiAqICBiZSBzZXQuXG4gKlxuICogIEBTZWUgW0Vycm9yQ29kZXNdKGFwaTpFcnJvckNvZGUpXG4gKiAgQGV4YW1wbGVcbiAqICAgIHRyeSB7XG4gKiAgICAgIC8vIGNvZGUuLi4uXG4gKiAgICB9IGNhdGNoIChlKSB7XG4gKiAgICAgIGlmIChpc0Vycm9yKGUsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAqICAgICAgICAgIC8vIFRoZSBUeXBlIEd1YXJkIGhhcyB2YWxpZGF0ZWQgdGhpcyBvYmplY3RcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKGUuZGF0YSk7XG4gKiAgICAgIH1cbiAqICAgIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3IoZXJyb3IsIGNvZGUpIHtcbiAgICByZXR1cm4gKGVycm9yICYmIGVycm9yLmNvZGUgPT09IGNvZGUpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUlZXJyb3IlJSBpcyBhIFtbQ2FsbEV4Y2VwdGlvbkVycm9yXS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikge1xuICAgIHJldHVybiBpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIG5ldyBFcnJvciBjb25maWd1cmVkIHRvIHRoZSBmb3JtYXQgZXRoZXJzIGVtaXRzIGVycm9ycywgd2l0aFxuICogIHRoZSAlJW1lc3NhZ2UlJSwgW1thcGk6RXJyb3JDb2RlXV0gJSVjb2RlJSUgYW5kIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogIGZvciB0aGUgY29ycmVzcG9uZGluZyBFdGhlcnNFcnJvci5cbiAqXG4gKiAgRWFjaCBlcnJvciBpbiBldGhlcnMgaW5jbHVkZXMgdGhlIHZlcnNpb24gb2YgZXRoZXJzLCBhXG4gKiAgbWFjaGluZS1yZWFkYWJsZSBbW0Vycm9yQ29kZV1dLCBhbmQgZGVwZW5kaW5nIG9uICUlY29kZSUlLCBhZGRpdGlvbmFsXG4gKiAgcmVxdWlyZWQgcHJvcGVydGllcy4gVGhlIGVycm9yIG1lc3NhZ2Ugd2lsbCBhbHNvIGluY2x1ZGUgdGhlICUlbWVzc2FnZSUlLFxuICogIGV0aGVycyB2ZXJzaW9uLCAlJWNvZGUlJSBhbmQgYWxsIGFkZGl0aW9uYWwgcHJvcGVydGllcywgc2VyaWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKSB7XG4gICAgbGV0IHNob3J0TWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gW107XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBpZiAoXCJtZXNzYWdlXCIgaW4gaW5mbyB8fCBcImNvZGVcIiBpbiBpbmZvIHx8IFwibmFtZVwiIGluIGluZm8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlIHdpbGwgb3ZlcndyaXRlIHBvcHVsYXRlZCB2YWx1ZXM6ICR7c3RyaW5naWZ5KGluZm8pfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwic2hvcnRNZXNzYWdlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKGluZm9ba2V5XSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBzdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNTU1cIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChrZXkgKyBcIj1bY291bGQgbm90IHNlcmlhbGl6ZSBvYmplY3RdXCIpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXRhaWxzLnB1c2goYGNvZGU9JHtjb2RlfWApO1xuICAgICAgICBkZXRhaWxzLnB1c2goYHZlcnNpb249JHt2ZXJzaW9ufWApO1xuICAgICAgICBpZiAoZGV0YWlscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgZGV0YWlscy5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZXJyb3I7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgXCJJTlZBTElEX0FSR1VNRU5UXCI6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk5VTUVSSUNfRkFVTFRcIjpcbiAgICAgICAgY2FzZSBcIkJVRkZFUl9PVkVSUlVOXCI6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBSYW5nZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBjb2RlIH0pO1xuICAgIGlmIChpbmZvKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZXJyb3IsIGluZm8pO1xuICAgIH1cbiAgICBpZiAoZXJyb3Iuc2hvcnRNZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBzaG9ydE1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbn1cbi8qKlxuICogIFRocm93cyBhbiBFdGhlcnNFcnJvciB3aXRoICUlbWVzc2FnZSUlLCAlJWNvZGUlJSBhbmQgYWRkaXRpb25hbCBlcnJvclxuICogICUlaW5mbyUlIHdoZW4gJSVjaGVjayUlIGlzIGZhbHNpc2guLlxuICpcbiAqICBAc2VlIFtbYXBpOm1ha2VFcnJvcl1dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcbiAgICBpZiAoIWNoZWNrKSB7XG4gICAgICAgIHRocm93IG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKTtcbiAgICB9XG59XG4vKipcbiAqICBBIHNpbXBsZSBoZWxwZXIgdG8gc2ltcGx5IGVuc3VyaW5nIHByb3ZpZGVkIGFyZ3VtZW50cyBtYXRjaCBleHBlY3RlZFxuICogIGNvbnN0cmFpbnRzLCB0aHJvd2luZyBpZiBub3QuXG4gKlxuICogIEluIFR5cGVTY3JpcHQgZW52aXJvbm1lbnRzLCB0aGUgJSVjaGVjayUlIGhhcyBiZWVuIGFzc2VydGVkIHRydWUsIHNvXG4gKiAgYW55IGZ1cnRoZXIgY29kZSBkb2VzIG5vdCBuZWVkIGFkZGl0aW9uYWwgY29tcGlsZS10aW1lIGNoZWNrcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50KGNoZWNrLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGFzc2VydChjaGVjaywgbWVzc2FnZSwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcmd1bWVudENvdW50KGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgfVxuICAgIGFzc2VydChjb3VudCA+PSBleHBlY3RlZENvdW50LCBcIm1pc3NpbmcgYXJndW1lbnRcIiArIG1lc3NhZ2UsIFwiTUlTU0lOR19BUkdVTUVOVFwiLCB7XG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgIH0pO1xuICAgIGFzc2VydChjb3VudCA8PSBleHBlY3RlZENvdW50LCBcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIsIHtcbiAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgfSk7XG59XG5jb25zdCBfbm9ybWFsaXplRm9ybXMgPSBbXCJORkRcIiwgXCJORkNcIiwgXCJORktEXCIsIFwiTkZLQ1wiXS5yZWR1Y2UoKGFjY3VtLCBmb3JtKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gR2VuZXJhbCB0ZXN0IGZvciBub3JtYWxpemVcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAoZm9ybSA9PT0gXCJORkRcIikge1xuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTkpLm5vcm1hbGl6ZShcIk5GRFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDY1LCAweDAzMDEpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoY2hlY2sgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgfVxuICAgICAgICBhY2N1bS5wdXNoKGZvcm0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBhY2N1bTtcbn0sIFtdKTtcbi8qKlxuICogIFRocm93cyBpZiB0aGUgbm9ybWFsaXphdGlvbiAlJWZvcm0lJSBpcyBub3Qgc3VwcG9ydGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Tm9ybWFsaXplKGZvcm0pIHtcbiAgICBhc3NlcnQoX25vcm1hbGl6ZUZvcm1zLmluZGV4T2YoZm9ybSkgPj0gMCwgXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIGluZm86IHsgZm9ybSB9XG4gICAgfSk7XG59XG4vKipcbiAqICBNYW55IGNsYXNzZXMgdXNlIGZpbGUtc2NvcGVkIHZhbHVlcyB0byBndWFyZCB0aGUgY29uc3RydWN0b3IsXG4gKiAgbWFraW5nIGl0IGVmZmVjdGl2ZWx5IHByaXZhdGUuIFRoaXMgZmFjaWxpdGF0ZXMgdGhhdCBwYXR0ZXJuXG4gKiAgYnkgZW5zdXJpbmcgdGhlICUlZ2l2ZW5HYXVyZCUlIG1hdGNoZXMgdGhlIGZpbGUtc2NvcGVkICUlZ3VhcmQlJSxcbiAqICB0aHJvd2luZyBpZiBub3QsIGluZGljYXRpbmcgdGhlICUlY2xhc3NOYW1lJSUgaWYgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQcml2YXRlKGdpdmVuR3VhcmQsIGd1YXJkLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoY2xhc3NOYW1lID09IG51bGwpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKGdpdmVuR3VhcmQgIT09IGd1YXJkKSB7XG4gICAgICAgIGxldCBtZXRob2QgPSBjbGFzc05hbWUsIG9wZXJhdGlvbiA9IFwibmV3XCI7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSBcIi5cIjtcbiAgICAgICAgICAgIG9wZXJhdGlvbiArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBwcml2YXRlIGNvbnN0cnVjdG9yOyB1c2UgJHttZXRob2R9ZnJvbSogbWV0aG9kc2AsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/fixednumber.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedNumber: () => (/* binding */ FixedNumber)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */\n\n\n\n\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\nconst _guard = {};\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile (Zeros.length < 80) {\n    Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n    let result = Zeros;\n    while (result.length < decimals) {\n        result += result;\n    }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = (BN_1 << (width - BN_1));\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || (val >= -limit && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        if (val > BN_0) {\n            val = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(val, width), width);\n        }\n        else {\n            val = -(0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(-val, width), width);\n        }\n    }\n    else {\n        const limit = (BN_1 << width);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || (val >= 0 && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        val = (((val % limit) + limit) % limit) & (limit - BN_1);\n    }\n    return val;\n}\nfunction getFormat(value) {\n    if (typeof (value) === \"number\") {\n        value = `fixed128x${value}`;\n    }\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n    if (typeof (value) === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n            // defaults...\n        }\n        else if (value === \"ufixed\") {\n            signed = false;\n        }\n        else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match, \"invalid fixed format\", \"format\", value);\n            signed = (match[1] !== \"u\");\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    }\n    else if (value) {\n        // Extract the values from the object\n        const v = value;\n        const check = (key, type, defaultValue) => {\n            if (v[key] == null) {\n                return defaultValue;\n            }\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (v[key]) === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n            return v[key];\n        };\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((width % 8) === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n    const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    return { signed, width, decimals, name };\n}\nfunction toString(val, decimals) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n    let str = val.toString();\n    // No decimal point for whole values\n    if (decimals === 0) {\n        return (negative + str);\n    }\n    // Pad out to the whole component (including a whole digit)\n    while (str.length <= decimals) {\n        str = Zeros + str;\n    }\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n    // Trim the whole component (leaving at least one 0)\n    while (str[0] === \"0\" && str[1] !== \".\") {\n        str = str.substring(1);\n    }\n    // Trim the decimal component (leaving at least one 0)\n    while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\n        str = str.substring(0, str.length - 1);\n    }\n    return (negative + str);\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, a value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */\nclass FixedNumber {\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    format;\n    #format;\n    // The actual value (accounting for decimals)\n    #val;\n    // A base-10 value to multiple values by to maintain the magnitude\n    #tens;\n    /**\n     *  This is a property so console.log shows a human-meaningful value.\n     *\n     *  @private\n     */\n    _value;\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n    /**\n     *  @private\n     */\n    constructor(guard, value, format) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"FixedNumber\");\n        this.#val = value;\n        this.#format = format;\n        const _value = toString(value, format.decimals);\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { format: format.name, _value });\n        this.#tens = getTens(format.decimals);\n    }\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */\n    get signed() { return this.#format.signed; }\n    /**\n     *  The number of bits available to store the value.\n     */\n    get width() { return this.#format.width; }\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */\n    get decimals() { return this.#format.decimals; }\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */\n    get value() { return this.#val; }\n    #checkFormat(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n    #checkValue(val, safeOp) {\n        /*\n                const width = BigInt(this.width);\n                if (this.signed) {\n                    const limit = (BN_1 << (width - BN_1));\n                    assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n        \n                    if (val > BN_0) {\n                        val = fromTwos(mask(val, width), width);\n                    } else {\n                        val = -fromTwos(mask(-val, width), width);\n                    }\n        \n                } else {\n                    const masked = mask(val, width);\n                    assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n                    val = masked;\n                }\n        */\n        val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n    #add(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */\n    addUnsafe(other) { return this.#add(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    add(other) { return this.#add(other, \"add\"); }\n    #sub(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */\n    subUnsafe(other) { return this.#sub(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    sub(other) { return this.#sub(other, \"sub\"); }\n    #mul(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */\n    mulUnsafe(other) { return this.#mul(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    mul(other) { return this.#mul(other, \"mul\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */\n    mulSignal(other) {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % this.#tens) === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n    #div(o, safeOp) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    divUnsafe(other) { return this.#div(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    div(other) { return this.#div(other, \"div\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */\n    divSignal(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(other);\n        const value = (this.#val * this.#tens);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % other.#val) === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */\n    cmp(other) {\n        let a = this.value, b = other.value;\n        // Coerce a and b to the same magnitude\n        const delta = this.decimals - other.decimals;\n        if (delta > 0) {\n            b *= getTens(delta);\n        }\n        else if (delta < 0) {\n            a *= getTens(-delta);\n        }\n        // Comnpare\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */\n    eq(other) { return this.cmp(other) === 0; }\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */\n    lt(other) { return this.cmp(other) < 0; }\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */\n    lte(other) { return this.cmp(other) <= 0; }\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */\n    gt(other) { return this.cmp(other) > 0; }\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */\n    gte(other) { return this.cmp(other) >= 0; }\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    floor() {\n        let val = this.#val;\n        if (this.#val < BN_0) {\n            val -= this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    ceiling() {\n        let val = this.#val;\n        if (this.#val > BN_0) {\n            val += this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) {\n            return this;\n        }\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = (value / tens) * tens;\n        checkValue(value, this.#format, \"round\");\n        return new FixedNumber(_guard, value, this.#format);\n    }\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */\n    isZero() { return (this.#val === BN_0); }\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */\n    isNegative() { return (this.#val < BN_0); }\n    /**\n     *  Returns the string representation of %%this%%.\n     */\n    toString() { return this._value; }\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */\n    toFormat(format) {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */\n    static fromValue(_value, _decimals, _format) {\n        const decimals = (_decimals == null) ? 0 : (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(_decimals);\n        const format = getFormat(_format);\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % tens) === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\", fault: \"underflow\", value: _value\n            });\n            value /= tens;\n        }\n        else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n        checkValue(value, format, \"fromValue\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */\n    static fromString(_value, _format) {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match && (match[2].length + match[3].length) > 0, \"invalid FixedNumber string value\", \"value\", _value);\n        const format = getFormat(_format);\n        let whole = (match[2] || \"0\"), decimal = (match[3] || \"\");\n        // Pad out the decimals\n        while (decimal.length < format.decimals) {\n            decimal += Zeros;\n        }\n        // Check precision is safe\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\", fault: \"underflow\", value: _value\n        });\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n        const value = BigInt(match[1] + whole + decimal);\n        checkValue(value, format, \"fromString\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */\n    static fromBytes(_value, _format) {\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt)((0,_data_js__WEBPACK_IMPORTED_MODULE_3__.getBytes)(_value, \"value\"));\n        const format = getFormat(_format);\n        if (format.signed) {\n            value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)(value, format.width);\n        }\n        checkValue(value, format, \"fromBytes\");\n        return new FixedNumber(_guard, value, format);\n    }\n}\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n//console.log(f1.divSignal(f2));\n//const BUMP = FixedNumber.from(\"0.5\");\n//# sourceMappingURL=fixednumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZml4ZWRudW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUMrQjtBQUNRO0FBQ3pCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLG1EQUFRLENBQUMsK0NBQUk7QUFDL0I7QUFDQTtBQUNBLG1CQUFtQixtREFBUSxDQUFDLCtDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwREFBYztBQUNsQixJQUFJLDBEQUFjO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdFQUFnQixTQUFTLDZCQUE2QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLFFBQVEsMERBQWMscURBQXFEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsb0RBQVM7QUFDNUQ7QUFDQSxvQkFBb0Isb0RBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrREFBTTtBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtREFBUSxDQUFDLGtEQUFRO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsbURBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL3NuYXBwL3BhY2thZ2VzL25leHRqcy9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZml4ZWRudW1iZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVGhlICoqRml4ZWROdW1iZXIqKiBjbGFzcyBwZXJtaXRzIHVzaW5nIHZhbHVlcyB3aXRoIGRlY2ltYWwgcGxhY2VzLFxuICogIHVzaW5nIGZpeGVkLXBvbnQgbWF0aC5cbiAqXG4gKiAgRml4ZWQtcG9pbnQgbWF0aCBpcyBzdGlsbCBiYXNlZCBvbiBpbnRlZ2VycyB1bmRlci10aGUtaG9vZCwgYnV0IHVzZXMgYW5cbiAqICBpbnRlcm5hbCBvZmZzZXQgdG8gc3RvcmUgZnJhY3Rpb25hbCBjb21wb25lbnRzIGJlbG93LCBhbmQgZWFjaCBvcGVyYXRpb25cbiAqICBjb3JyZWN0cyBmb3IgdGhpcyBhZnRlciBlYWNoIG9wZXJhdGlvbi5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvdXRpbHMvZml4ZWQtcG9pbnQtbWF0aDpGaXhlZC1Qb2ludCBNYXRocyAgW2Fib3V0LWZpeGVkLXBvaW50LW1hdGhdXG4gKi9cbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgYXNzZXJ0UHJpdmF0ZSB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGZyb21Ud29zLCBtYXNrLCB0b0JpZ0ludCB9IGZyb20gXCIuL21hdGhzLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuY29uc3QgQk5fTjEgPSBCaWdJbnQoLTEpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl81ID0gQmlnSW50KDUpO1xuY29uc3QgX2d1YXJkID0ge307XG4vLyBDb25zdGFudCB0byBwdWxsIHplcm9zIGZyb20gZm9yIG11bHRpcGxpZXJzXG5sZXQgWmVyb3MgPSBcIjAwMDBcIjtcbndoaWxlIChaZXJvcy5sZW5ndGggPCA4MCkge1xuICAgIFplcm9zICs9IFplcm9zO1xufVxuLy8gUmV0dXJucyBhIHN0cmluZyBcIjFcIiBmb2xsb3dlZCBieSBkZWNpbWFsIFwiMFwic1xuZnVuY3Rpb24gZ2V0VGVucyhkZWNpbWFscykge1xuICAgIGxldCByZXN1bHQgPSBaZXJvcztcbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IGRlY2ltYWxzKSB7XG4gICAgICAgIHJlc3VsdCArPSByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoXCIxXCIgKyByZXN1bHQuc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSk7XG59XG5mdW5jdGlvbiBjaGVja1ZhbHVlKHZhbCwgZm9ybWF0LCBzYWZlT3ApIHtcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChmb3JtYXQud2lkdGgpO1xuICAgIGlmIChmb3JtYXQuc2lnbmVkKSB7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAtbGltaXQgJiYgdmFsIDwgbGltaXQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IHNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbCA+IEJOXzApIHtcbiAgICAgICAgICAgIHZhbCA9IGZyb21Ud29zKG1hc2sodmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IC1mcm9tVHdvcyhtYXNrKC12YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBsaW1pdCA9IChCTl8xIDw8IHdpZHRoKTtcbiAgICAgICAgYXNzZXJ0KHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gMCAmJiB2YWwgPCBsaW1pdCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogc2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgIH0pO1xuICAgICAgICB2YWwgPSAoKCh2YWwgJSBsaW1pdCkgKyBsaW1pdCkgJSBsaW1pdCkgJiAobGltaXQgLSBCTl8xKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGdldEZvcm1hdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB2YWx1ZSA9IGBmaXhlZDEyOHgke3ZhbHVlfWA7XG4gICAgfVxuICAgIGxldCBzaWduZWQgPSB0cnVlO1xuICAgIGxldCB3aWR0aCA9IDEyODtcbiAgICBsZXQgZGVjaW1hbHMgPSAxODtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gUGFyc2UgdGhlIGZvcm1hdCBzdHJpbmdcbiAgICAgICAgaWYgKHZhbHVlID09PSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHRzLi4uXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IFwidWZpeGVkXCIpIHtcbiAgICAgICAgICAgIHNpZ25lZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXih1PylmaXhlZChbMC05XSspeChbMC05XSspJC8pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQobWF0Y2gsIFwiaW52YWxpZCBmaXhlZCBmb3JtYXRcIiwgXCJmb3JtYXRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgc2lnbmVkID0gKG1hdGNoWzFdICE9PSBcInVcIik7XG4gICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIHZhbHVlcyBmcm9tIHRoZSBvYmplY3RcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlO1xuICAgICAgICBjb25zdCBjaGVjayA9IChrZXksIHR5cGUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodltrZXldKSA9PT0gdHlwZSwgXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCAoXCIgKyBrZXkgKyBcIiBub3QgXCIgKyB0eXBlICsgXCIpXCIsIFwiZm9ybWF0LlwiICsga2V5LCB2W2tleV0pO1xuICAgICAgICAgICAgcmV0dXJuIHZba2V5XTtcbiAgICAgICAgfTtcbiAgICAgICAgc2lnbmVkID0gY2hlY2soXCJzaWduZWRcIiwgXCJib29sZWFuXCIsIHNpZ25lZCk7XG4gICAgICAgIHdpZHRoID0gY2hlY2soXCJ3aWR0aFwiLCBcIm51bWJlclwiLCB3aWR0aCk7XG4gICAgICAgIGRlY2ltYWxzID0gY2hlY2soXCJkZWNpbWFsc1wiLCBcIm51bWJlclwiLCBkZWNpbWFscyk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KCh3aWR0aCAlIDgpID09PSAwLCBcImludmFsaWQgRml4ZWROdW1iZXIgd2lkdGggKG5vdCBieXRlIGFsaWduZWQpXCIsIFwiZm9ybWF0LndpZHRoXCIsIHdpZHRoKTtcbiAgICBhc3NlcnRBcmd1bWVudChkZWNpbWFscyA8PSA4MCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIGRlY2ltYWxzICh0b28gbGFyZ2UpXCIsIFwiZm9ybWF0LmRlY2ltYWxzXCIsIGRlY2ltYWxzKTtcbiAgICBjb25zdCBuYW1lID0gKHNpZ25lZCA/IFwiXCIgOiBcInVcIikgKyBcImZpeGVkXCIgKyBTdHJpbmcod2lkdGgpICsgXCJ4XCIgKyBTdHJpbmcoZGVjaW1hbHMpO1xuICAgIHJldHVybiB7IHNpZ25lZCwgd2lkdGgsIGRlY2ltYWxzLCBuYW1lIH07XG59XG5mdW5jdGlvbiB0b1N0cmluZyh2YWwsIGRlY2ltYWxzKSB7XG4gICAgbGV0IG5lZ2F0aXZlID0gXCJcIjtcbiAgICBpZiAodmFsIDwgQk5fMCkge1xuICAgICAgICBuZWdhdGl2ZSA9IFwiLVwiO1xuICAgICAgICB2YWwgKj0gQk5fTjE7XG4gICAgfVxuICAgIGxldCBzdHIgPSB2YWwudG9TdHJpbmcoKTtcbiAgICAvLyBObyBkZWNpbWFsIHBvaW50IGZvciB3aG9sZSB2YWx1ZXNcbiAgICBpZiAoZGVjaW1hbHMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIChuZWdhdGl2ZSArIHN0cik7XG4gICAgfVxuICAgIC8vIFBhZCBvdXQgdG8gdGhlIHdob2xlIGNvbXBvbmVudCAoaW5jbHVkaW5nIGEgd2hvbGUgZGlnaXQpXG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPD0gZGVjaW1hbHMpIHtcbiAgICAgICAgc3RyID0gWmVyb3MgKyBzdHI7XG4gICAgfVxuICAgIC8vIEluc2VydCB0aGUgZGVjaW1hbCBwb2ludFxuICAgIGNvbnN0IGluZGV4ID0gc3RyLmxlbmd0aCAtIGRlY2ltYWxzO1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaW5kZXgpICsgXCIuXCIgKyBzdHIuc3Vic3RyaW5nKGluZGV4KTtcbiAgICAvLyBUcmltIHRoZSB3aG9sZSBjb21wb25lbnQgKGxlYXZpbmcgYXQgbGVhc3Qgb25lIDApXG4gICAgd2hpbGUgKHN0clswXSA9PT0gXCIwXCIgJiYgc3RyWzFdICE9PSBcIi5cIikge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICAvLyBUcmltIHRoZSBkZWNpbWFsIGNvbXBvbmVudCAobGVhdmluZyBhdCBsZWFzdCBvbmUgMClcbiAgICB3aGlsZSAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gXCIwXCIgJiYgc3RyW3N0ci5sZW5ndGggLSAyXSAhPT0gXCIuXCIpIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiAobmVnYXRpdmUgKyBzdHIpO1xufVxuLyoqXG4gKiAgQSBGaXhlZE51bWJlciByZXByZXNlbnRzIGEgdmFsdWUgb3ZlciBpdHMgW1tGaXhlZEZvcm1hdF1dXG4gKiAgYXJpdGhtZXRpYyBmaWVsZC5cbiAqXG4gKiAgQSBGaXhlZE51bWJlciBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIG1hdGgsIGxvc3NsZXNzbHksIG9uXG4gKiAgdmFsdWVzIHdoaWNoIGhhdmUgZGVjbWlhbCBwbGFjZXMuXG4gKlxuICogIEEgRml4ZWROdW1iZXIgaGFzIGEgZml4ZWQgYml0LXdpZHRoIHRvIHN0b3JlIHZhbHVlcyBpbiwgYW5kIHN0b3JlcyBhbGxcbiAqICB2YWx1ZXMgaW50ZXJuYWxseSBieSBtdWx0aXBseWluZyB0aGUgdmFsdWUgYnkgMTAgcmFpc2VkIHRvIHRoZSBwb3dlciBvZlxuICogICUlZGVjaW1hbHMlJS5cbiAqXG4gKiAgSWYgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIHRoYXQgY2F1c2UgYSB2YWx1ZSB0byBncm93IHRvbyBoaWdoIChjbG9zZSB0b1xuICogIHBvc2l0aXZlIGluZmluaXR5KSBvciB0b28gbG93IChjbG9zZSB0byBuZWdhdGl2ZSBpbmZpbml0eSksIHRoZSB2YWx1ZVxuICogIGlzIHNhaWQgdG8gLy9vdmVyZmxvdy8vLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgYW4gOC1iaXQgc2lnbmVkIHZhbHVlLCB3aXRoIDAgZGVjaW1hbHMgbWF5IG9ubHkgYmUgd2l0aGluXG4gKiAgdGhlIHJhbmdlIGBgLTEyOGBgIHRvIGBgMTI3YGA7IHNvIGBgLTEyOCAtIDFgYCB3aWxsIG92ZXJmbG93IGFuZCBiZWNvbWVcbiAqICBgYDEyN2BgLiBMaWtld2lzZSwgYGAxMjcgKyAxYGAgd2lsbCBvdmVyZmxvdyBhbmQgYmVjb21lIGBgLTEyN2BgLlxuICpcbiAqICBNYW55IG9wZXJhdGlvbiBoYXZlIGEgbm9ybWFsIGFuZCAvL3Vuc2FmZS8vIHZhcmlhbnQuIFRoZSBub3JtYWwgdmFyaWFudFxuICogIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gb24gYW55IG92ZXJmbG93LCB3aGlsZSB0aGUgLy91bnNhZmUvL1xuICogIHZhcmlhbnQgd2lsbCBzaWxlbnRseSBhbGxvdyBvdmVyZmxvdywgY29ycnVwdGluZyBpdHMgdmFsdWUgdmFsdWUuXG4gKlxuICogIElmIG9wZXJhdGlvbnMgYXJlIHBlcmZvcm1lZCB0aGF0IGNhdXNlIGEgdmFsdWUgdG8gYmVjb21lIHRvbyBzbWFsbFxuICogIChjbG9zZSB0byB6ZXJvKSwgdGhlIHZhbHVlIGxvc2VzIHByZWNpc29uIGFuZCBpcyBzYWlkIHRvIC8vdW5kZXJmbG93Ly8uXG4gKlxuICogIEZvciBleGFtcGxlLCBhIHZhbHVlIHdpdGggMSBkZWNpbWFsIHBsYWNlIG1heSBzdG9yZSBhIG51bWJlciBhcyBzbWFsbFxuICogIGFzIGBgMC4xYGAsIGJ1dCB0aGUgdmFsdWUgb2YgYGAwLjEgLyAyYGAgaXMgYGAwLjA1YGAsIHdoaWNoIGNhbm5vdCBmaXRcbiAqICBpbnRvIDEgZGVjaW1hbCBwbGFjZSwgc28gdW5kZXJmbG93IG9jY3VycyB3aGljaCBtZWFucyBwcmVjaXNpb24gaXMgbG9zdFxuICogIGFuZCB0aGUgdmFsdWUgYmVjb21lcyBgYDBgYC5cbiAqXG4gKiAgU29tZSBvcGVyYXRpb25zIGhhdmUgYSBub3JtYWwgYW5kIC8vc2lnbmFsbGluZy8vIHZhcmlhbnQuIFRoZSBub3JtYWxcbiAqICB2YXJpYW50IHdpbGwgc2lsZW50bHkgaWdub3JlIHVuZGVyZmxvdywgd2hpbGUgdGhlIC8vc2lnbmFsbGluZy8vIHZhcmlhbnRcbiAqICB3aWxsIHRob3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gb24gdW5kZXJmbG93LlxuICovXG5leHBvcnQgY2xhc3MgRml4ZWROdW1iZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgc3BlY2lmaWMgZml4ZWQtcG9pbnQgYXJpdGhtZXRpYyBmaWVsZCBmb3IgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBmb3JtYXQ7XG4gICAgI2Zvcm1hdDtcbiAgICAvLyBUaGUgYWN0dWFsIHZhbHVlIChhY2NvdW50aW5nIGZvciBkZWNpbWFscylcbiAgICAjdmFsO1xuICAgIC8vIEEgYmFzZS0xMCB2YWx1ZSB0byBtdWx0aXBsZSB2YWx1ZXMgYnkgdG8gbWFpbnRhaW4gdGhlIG1hZ25pdHVkZVxuICAgICN0ZW5zO1xuICAgIC8qKlxuICAgICAqICBUaGlzIGlzIGEgcHJvcGVydHkgc28gY29uc29sZS5sb2cgc2hvd3MgYSBodW1hbi1tZWFuaW5nZnVsIHZhbHVlLlxuICAgICAqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgX3ZhbHVlO1xuICAgIC8vIFVzZSB0aGlzIHdoZW4gY2hhbmdpbmcgdGhpcyBmaWxlIHRvIGdldCBzb21lIHR5cGluZyBpbmZvLFxuICAgIC8vIGJ1dCB0aGVuIHN3aXRjaCB0byBhbnkgdG8gbWFzayB0aGUgaW50ZXJuYWwgdHlwZVxuICAgIC8vY29uc3RydWN0b3IoZ3VhcmQ6IGFueSwgdmFsdWU6IGJpZ2ludCwgZm9ybWF0OiBfRml4ZWRGb3JtYXQpIHtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiRml4ZWROdW1iZXJcIik7XG4gICAgICAgIHRoaXMuI3ZhbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLiNmb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIGNvbnN0IF92YWx1ZSA9IHRvU3RyaW5nKHZhbHVlLCBmb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZm9ybWF0OiBmb3JtYXQubmFtZSwgX3ZhbHVlIH0pO1xuICAgICAgICB0aGlzLiN0ZW5zID0gZ2V0VGVucyhmb3JtYXQuZGVjaW1hbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdHJ1ZSwgbmVnYXRpdmUgdmFsdWVzIGFyZSBwZXJtaXR0ZWQsIG90aGVyd2lzZSBvbmx5XG4gICAgICogIHBvc2l0aXZlIHZhbHVlcyBhbmQgemVybyBhcmUgYWxsb3dlZC5cbiAgICAgKi9cbiAgICBnZXQgc2lnbmVkKCkgeyByZXR1cm4gdGhpcy4jZm9ybWF0LnNpZ25lZDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIGJpdHMgYXZhaWxhYmxlIHRvIHN0b3JlIHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLiNmb3JtYXQud2lkdGg7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBpbiB0aGUgZml4ZWQtcG9pbnQgYXJpdGhtZW50IGZpZWxkLlxuICAgICAqL1xuICAgIGdldCBkZWNpbWFscygpIHsgcmV0dXJuIHRoaXMuI2Zvcm1hdC5kZWNpbWFsczsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUgYXMgYW4gaW50ZWdlciwgYmFzZWQgb24gdGhlIHNtYWxsZXN0IHVuaXQgdGhlXG4gICAgICogIFtbZGVjaW1hbHNdXSBhbGxvdy5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7IHJldHVybiB0aGlzLiN2YWw7IH1cbiAgICAjY2hlY2tGb3JtYXQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodGhpcy5mb3JtYXQgPT09IG90aGVyLmZvcm1hdCwgXCJpbmNvbXBhdGlibGUgZm9ybWF0OyB1c2UgZml4ZWROdW1iZXIudG9Gb3JtYXRcIiwgXCJvdGhlclwiLCBvdGhlcik7XG4gICAgfVxuICAgICNjaGVja1ZhbHVlKHZhbCwgc2FmZU9wKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBCaWdJbnQodGhpcy53aWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAtbGltaXQgICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPiBCTl8wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBmcm9tVHdvcyhtYXNrKHZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSAtZnJvbVR3b3MobWFzaygtdmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrZWQgPSBtYXNrKHZhbCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAwICYmIHZhbCA9PT0gbWFza2VkKSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbWFza2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgdmFsID0gY2hlY2tWYWx1ZSh2YWwsIHRoaXMuI2Zvcm1hdCwgc2FmZU9wKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbCwgdGhpcy4jZm9ybWF0KTtcbiAgICB9XG4gICAgI2FkZChvLCBzYWZlT3ApIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHRoaXMuI3ZhbCArIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBhZGRlZFxuICAgICAqICB0byAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93LlxuICAgICAqL1xuICAgIGFkZFVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jYWRkKG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgYWRkZWRcbiAgICAgKiAgdG8gJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIGFkZChvdGhlcikgeyByZXR1cm4gdGhpcy4jYWRkKG90aGVyLCBcImFkZFwiKTsgfVxuICAgICNzdWIobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh0aGlzLiN2YWwgLSBvLiN2YWwsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSVvdGhlciUlIHN1YnRyYWN0ZWRcbiAgICAgKiAgZnJvbSAlJXRoaXMlJSwgaWdub3Jpbmcgb3ZlcmZsb3cuXG4gICAgICovXG4gICAgc3ViVW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNzdWIob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJW90aGVyJSUgc3VidHJhY3RlZFxuICAgICAqICBmcm9tICUldGhpcyUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIHN1YihvdGhlcikgeyByZXR1cm4gdGhpcy4jc3ViKG90aGVyLCBcInN1YlwiKTsgfVxuICAgICNtdWwobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSgodGhpcy4jdmFsICogby4jdmFsKSAvIHRoaXMuI3RlbnMsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93IGFuZCB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBtdWxVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI211bChvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIG11bHRpcGxpZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIG11bChvdGhlcikgeyByZXR1cm4gdGhpcy4jbXVsKG90aGVyLCBcIm11bFwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMgb3IgaWYgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykgb2NjdXJzLlxuICAgICAqL1xuICAgIG11bFNpZ25hbChvdGhlcikge1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmFsICogb3RoZXIuI3ZhbDtcbiAgICAgICAgYXNzZXJ0KCh2YWx1ZSAlIHRoaXMuI3RlbnMpID09PSBCTl8wLCBcInByZWNpc2lvbiBsb3N0IGR1cmluZyBzaWduYWxsaW5nIG11bFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm11bFNpZ25hbFwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbHVlIC8gdGhpcy4jdGVucywgXCJtdWxTaWduYWxcIik7XG4gICAgfVxuICAgICNkaXYobywgc2FmZU9wKSB7XG4gICAgICAgIGFzc2VydChvLiN2YWwgIT09IEJOXzAsIFwiZGl2aXNpb24gYnkgemVyb1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlwiLCBmYXVsdDogXCJkaXZpZGUtYnktemVyb1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKCh0aGlzLiN2YWwgKiB0aGlzLiN0ZW5zKSAvIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3JpbmcgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuIEFcbiAgICAgKiAgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvdyBvY2N1cnMuXG4gICAgICovXG4gICAgZGl2VW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNkaXYob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3JpbmcgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuIEFcbiAgICAgKiAgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvdyBvY2N1cnMuXG4gICAgICovXG4gICAgZGl2KG90aGVyKSB7IHJldHVybiB0aGlzLiNkaXYob3RoZXIsIFwiZGl2XCIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIHVuZGVyZmxvd1xuICAgICAqICAocHJlY2lzaW9uIGxvc3MpIG9jY3Vycy5cbiAgICAgKi9cbiAgICBkaXZTaWduYWwob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0KG90aGVyLiN2YWwgIT09IEJOXzAsIFwiZGl2aXNpb24gYnkgemVyb1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlwiLCBmYXVsdDogXCJkaXZpZGUtYnktemVyb1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9ICh0aGlzLiN2YWwgKiB0aGlzLiN0ZW5zKTtcbiAgICAgICAgYXNzZXJ0KCh2YWx1ZSAlIG90aGVyLiN2YWwpID09PSBCTl8wLCBcInByZWNpc2lvbiBsb3N0IGR1cmluZyBzaWduYWxsaW5nIGRpdlwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlNpZ25hbFwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbHVlIC8gb3RoZXIuI3ZhbCwgXCJkaXZTaWduYWxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgY29tcGFyaXNvbiByZXN1bHQgYmV0d2VlbiAlJXRoaXMlJSBhbmQgJSVvdGhlciUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgc3VpdGFibGUgZm9yIHVzZSBpbiBzb3J0aW5nLCB3aGVyZSBgYC0xYGAgaW1wbGllcyAlJXRoaXMlJVxuICAgICAqICBpcyBzbWFsbGVyLCBgYDFgYCBpbXBsaWVzICUldGhpcyUlIGlzIGxhcmdlciBhbmQgYGAwYGAgaW1wbGllc1xuICAgICAqICBib3RoIGFyZSBlcXVhbC5cbiAgICAgKi9cbiAgICBjbXAob3RoZXIpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLnZhbHVlLCBiID0gb3RoZXIudmFsdWU7XG4gICAgICAgIC8vIENvZXJjZSBhIGFuZCBiIHRvIHRoZSBzYW1lIG1hZ25pdHVkZVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuZGVjaW1hbHMgLSBvdGhlci5kZWNpbWFscztcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgYiAqPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIGEgKj0gZ2V0VGVucygtZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbW5wYXJlXG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhID4gYikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPT09IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBsZXNzIHRoYW4gdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgbHQob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA8IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgbHRlKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPD0gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGdyZWF0ZXIgdGhhbiB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBndChvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpID4gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBndGUob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA+PSAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdoaWNoIGlzIHRoZSBsYXJnZXN0ICoqaW50ZWdlcioqXG4gICAgICogIHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqXG4gICAgICogIFRoZSBkZWNpbWFsIGNvbXBvbmVudCBvZiB0aGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGBgMGBgLlxuICAgICAqL1xuICAgIGZsb29yKCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcy4jdmFsO1xuICAgICAgICBpZiAodGhpcy4jdmFsIDwgQk5fMCkge1xuICAgICAgICAgICAgdmFsIC09IHRoaXMuI3RlbnMgLSBCTl8xO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9ICh0aGlzLiN2YWwgLyB0aGlzLiN0ZW5zKSAqIHRoaXMuI3RlbnM7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbCwgXCJmbG9vclwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdoaWNoIGlzIHRoZSBzbWFsbGVzdCAqKmludGVnZXIqKlxuICAgICAqICB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKlxuICAgICAqICBUaGUgZGVjaW1hbCBjb21wb25lbnQgb2YgdGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBgYDBgYC5cbiAgICAgKi9cbiAgICBjZWlsaW5nKCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcy4jdmFsO1xuICAgICAgICBpZiAodGhpcy4jdmFsID4gQk5fMCkge1xuICAgICAgICAgICAgdmFsICs9IHRoaXMuI3RlbnMgLSBCTl8xO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9ICh0aGlzLiN2YWwgLyB0aGlzLiN0ZW5zKSAqIHRoaXMuI3RlbnM7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbCwgXCJjZWlsaW5nXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgZGVjaW1hbCBjb21wb25lbnRcbiAgICAgKiAgcm91bmRlZCB1cCBvbiB0aWVzIGF0ICUlZGVjaW1hbHMlJSBwbGFjZXMuXG4gICAgICovXG4gICAgcm91bmQoZGVjaW1hbHMpIHtcbiAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgZW5vdWdoIHByZWNpc2lvbiB0byBub3QgYWxyZWFkeSBiZSByb3VuZGVkXG4gICAgICAgIGlmIChkZWNpbWFscyA+PSB0aGlzLmRlY2ltYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuZGVjaW1hbHMgLSBkZWNpbWFscztcbiAgICAgICAgY29uc3QgYnVtcCA9IEJOXzUgKiBnZXRUZW5zKGRlbHRhIC0gMSk7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWUgKyBidW1wO1xuICAgICAgICBjb25zdCB0ZW5zID0gZ2V0VGVucyhkZWx0YSk7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIC8gdGVucykgKiB0ZW5zO1xuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCB0aGlzLiNmb3JtYXQsIFwicm91bmRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgdGhpcy4jZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBlcXVhbCB0byBgYDBgYC5cbiAgICAgKi9cbiAgICBpc1plcm8oKSB7IHJldHVybiAodGhpcy4jdmFsID09PSBCTl8wKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgbGVzcyB0aGFuIGBgMGBgLlxuICAgICAqL1xuICAgIGlzTmVnYXRpdmUoKSB7IHJldHVybiAodGhpcy4jdmFsIDwgQk5fMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mICUldGhpcyUlLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZsb2F0IGFwcHJveGltYXRpb24uXG4gICAgICpcbiAgICAgKiAgRHVlIHRvIElFRUUgNzU0IHByZWNpc3Npb24gKG9yIGxhY2sgdGhlcmVvZiksIHRoaXMgZnVuY3Rpb25cbiAgICAgKiAgY2FuIG9ubHkgcmV0dXJuIGFuIGFwcHJveGltYXRpb24gYW5kIG1vc3QgdmFsdWVzIHdpbGwgY29udGFpblxuICAgICAqICByb3VuZGluZyBlcnJvcnMuXG4gICAgICovXG4gICAgdG9VbnNhZmVGbG9hdCgpIHsgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy50b1N0cmluZygpKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHNhbWUgdmFsdWUgYnV0IGhhcyBoYWRcbiAgICAgKiAgaXRzIGZpZWxkIHNldCB0byAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGUgdmFsdWUgY2Fubm90IGZpdCBpbnRvICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgdG9Gb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHRoaXMudG9TdHJpbmcoKSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIGZvciAlJXZhbHVlJSUgZGl2aWRlZCBieVxuICAgICAqICAlJWRlY2ltYWwlJSBwbGFjZXMgd2l0aCAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpZiAlJXZhbHVlJSUgKG9uY2UgYWRqdXN0ZWRcbiAgICAgKiAgZm9yICUlZGVjaW1hbHMlJSkgY2Fubm90IGZpdCBpbiAlJWZvcm1hdCUlLCBlaXRoZXIgZHVlIHRvIG92ZXJmbG93XG4gICAgICogIG9yIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVmFsdWUoX3ZhbHVlLCBfZGVjaW1hbHMsIF9mb3JtYXQpIHtcbiAgICAgICAgY29uc3QgZGVjaW1hbHMgPSAoX2RlY2ltYWxzID09IG51bGwpID8gMCA6IGdldE51bWJlcihfZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBnZXRGb3JtYXQoX2Zvcm1hdCk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gZGVjaW1hbHMgLSBmb3JtYXQuZGVjaW1hbHM7XG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRlbnMgPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgICAgIGFzc2VydCgodmFsdWUgJSB0ZW5zKSA9PT0gQk5fMCwgXCJ2YWx1ZSBsb3NlcyBwcmVjaXNpb24gZm9yIGZvcm1hdFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVmFsdWVcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFsdWUgLz0gdGVucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIHZhbHVlICo9IGdldFRlbnMoLWRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbVZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSBmb3IgJSV2YWx1ZSUlIHdpdGggJSVmb3JtYXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gaWYgJSV2YWx1ZSUlIGNhbm5vdCBmaXRcbiAgICAgKiAgaW4gJSVmb3JtYXQlJSwgZWl0aGVyIGR1ZSB0byBvdmVyZmxvdyBvciB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhfdmFsdWUsIF9mb3JtYXQpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBfdmFsdWUubWF0Y2goL14oLT8pKFswLTldKilcXC4/KFswLTldKikkLyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KG1hdGNoICYmIChtYXRjaFsyXS5sZW5ndGggKyBtYXRjaFszXS5sZW5ndGgpID4gMCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHN0cmluZyB2YWx1ZVwiLCBcInZhbHVlXCIsIF92YWx1ZSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgbGV0IHdob2xlID0gKG1hdGNoWzJdIHx8IFwiMFwiKSwgZGVjaW1hbCA9IChtYXRjaFszXSB8fCBcIlwiKTtcbiAgICAgICAgLy8gUGFkIG91dCB0aGUgZGVjaW1hbHNcbiAgICAgICAgd2hpbGUgKGRlY2ltYWwubGVuZ3RoIDwgZm9ybWF0LmRlY2ltYWxzKSB7XG4gICAgICAgICAgICBkZWNpbWFsICs9IFplcm9zO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHByZWNpc2lvbiBpcyBzYWZlXG4gICAgICAgIGFzc2VydChkZWNpbWFsLnN1YnN0cmluZyhmb3JtYXQuZGVjaW1hbHMpLm1hdGNoKC9eMCokLyksIFwidG9vIG1hbnkgZGVjaW1hbHMgZm9yIGZvcm1hdFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyb21TdHJpbmdcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlbW92ZSBleHRyYSBwYWRkaW5nXG4gICAgICAgIGRlY2ltYWwgPSBkZWNpbWFsLnN1YnN0cmluZygwLCBmb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChtYXRjaFsxXSArIHdob2xlICsgZGVjaW1hbCk7XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIGZvcm1hdCwgXCJmcm9tU3RyaW5nXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSBiaWctZW5kaWFuIHJlcHJlc2VudGF0aW9uXG4gICAgICogICUldmFsdWUlJSB3aXRoICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSBjYW5ub3QgZml0XG4gICAgICogIGluICUlZm9ybWF0JSUgZHVlIHRvIG92ZXJmbG93LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnl0ZXMoX3ZhbHVlLCBfZm9ybWF0KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRvQmlnSW50KGdldEJ5dGVzKF92YWx1ZSwgXCJ2YWx1ZVwiKSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgaWYgKGZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZnJvbVR3b3ModmFsdWUsIGZvcm1hdC53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21CeXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbn1cbi8vY29uc3QgZjEgPSBGaXhlZE51bWJlci5mcm9tU3RyaW5nKFwiMTIuNTZcIiwgXCJmaXhlZDE2eDJcIik7XG4vL2NvbnN0IGYyID0gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhcIjAuM1wiLCBcImZpeGVkMTZ4MlwiKTtcbi8vY29uc29sZS5sb2coZjEuZGl2U2lnbmFsKGYyKSk7XG4vL2NvbnN0IEJVTVAgPSBGaXhlZE51bWJlci5mcm9tKFwiMC41XCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWRudW1iZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/maths.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/maths.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTwos: () => (/* binding */ fromTwos),\n/* harmony export */   getBigInt: () => (/* binding */ getBigInt),\n/* harmony export */   getNumber: () => (/* binding */ getNumber),\n/* harmony export */   getUint: () => (/* binding */ getUint),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   toBeArray: () => (/* binding */ toBeArray),\n/* harmony export */   toBeHex: () => (/* binding */ toBeHex),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toQuantity: () => (/* binding */ toQuantity),\n/* harmony export */   toTwos: () => (/* binding */ toTwos)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nfunction fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> (width - BN_1)) {\n        const mask = (BN_1 << width) - BN_1;\n        return -(((~value) & mask) + BN_1);\n    }\n    return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nfunction toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = (BN_1 << (width - BN_1));\n    if (value < BN_0) {\n        value = -value;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return ((~value) & mask) + BN_1;\n    }\n    else {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n    }\n    return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nfunction mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getBigInt(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            }\n            catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nfunction getUint(value, name) {\n    const result = getBigInt(value, name);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nfunction toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getNumber(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            }\n            catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nfunction toNumber(value) {\n    return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nfunction toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    }\n    else {\n        const width = getNumber(_width, \"width\");\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(width * 2 >= result.length, `value exceeds width (${width} bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while (result.length < (width * 2)) {\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nfunction toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < result.length; i++) {\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nfunction toQuantity(value) {\n    let result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_data_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) {\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n}\n//# sourceMappingURL=maths.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUQ7QUFDSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSSxrREFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFjO0FBQzFCLFlBQVksMERBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFjLHdDQUF3QyxVQUFVO0FBQ2hGO0FBQ0E7QUFDQSxJQUFJLDBEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsSUFBSSxrREFBTTtBQUNWO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsWUFBWSwwREFBYztBQUMxQjtBQUNBO0FBQ0EsWUFBWSwwREFBYztBQUMxQixZQUFZLDBEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwREFBYyxtQ0FBbUMsVUFBVTtBQUMzRTtBQUNBO0FBQ0EsSUFBSSwwREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTSxxREFBcUQsT0FBTztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIsaURBQU8sQ0FBQyxxREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL3NuYXBwL3BhY2thZ2VzL25leHRqcy9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgU29tZSBtYXRoZW1hdGljIG9wZXJhdGlvbnMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOk1hdGggSGVscGVycyAgW2Fib3V0LW1hdGhzXVxuICovXG5pbXBvcnQgeyBoZXhsaWZ5LCBpc0J5dGVzTGlrZSB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuLy9jb25zdCBCTl9NYXgyNTYgPSAoQk5fMSA8PCBCaWdJbnQoMjU2KSkgLSBCTl8xO1xuLy8gSUVFRSA3NTQgc3VwcG9ydCA1My1iaXRzIG9mIG1hbnRpc3NhXG5jb25zdCBtYXhWYWx1ZSA9IDB4MWZmZmZmZmZmZmZmZmY7XG4vKipcbiAqICBDb252ZXJ0ICUldmFsdWUlJSBmcm9tIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mICUld2lkdGglJVxuICogIGJpdHMgdG8gaXRzIHZhbHVlLlxuICpcbiAqICBJZiB0aGUgaGlnaGVzdCBiaXQgaXMgYGAxYGAsIHRoZSByZXN1bHQgd2lsbCBiZSBuZWdhdGl2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Ud29zKF92YWx1ZSwgX3dpZHRoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpKTtcbiAgICBhc3NlcnQoKHZhbHVlID4+IHdpZHRoKSA9PT0gQk5fMCwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiZnJvbVR3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgIH0pO1xuICAgIC8vIFRvcCBiaXQgc2V0OyB0cmVhdCBhcyBhIG5lZ2F0aXZlIHZhbHVlXG4gICAgaWYgKHZhbHVlID4+ICh3aWR0aCAtIEJOXzEpKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xuICAgICAgICByZXR1cm4gLSgoKH52YWx1ZSkgJiBtYXNrKSArIEJOXzEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqICBDb252ZXJ0ICUldmFsdWUlJSB0byBhIHR3b3MtY29tcGxpbWVudCByZXByZXNlbnRhdGlvbiBvZlxuICogICUld2lkdGglJSBiaXRzLlxuICpcbiAqICBUaGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIHBvc2l0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Ud29zKF92YWx1ZSwgX3dpZHRoKSB7XG4gICAgbGV0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpKTtcbiAgICBjb25zdCBsaW1pdCA9IChCTl8xIDw8ICh3aWR0aCAtIEJOXzEpKTtcbiAgICBpZiAodmFsdWUgPCBCTl8wKSB7XG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgICAgICBhc3NlcnQodmFsdWUgPD0gbGltaXQsIFwidG9vIGxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtYXNrID0gKEJOXzEgPDwgd2lkdGgpIC0gQk5fMTtcbiAgICAgICAgcmV0dXJuICgofnZhbHVlKSAmIG1hc2spICsgQk5fMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydCh2YWx1ZSA8IGxpbWl0LCBcInRvbyBoaWdoXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogIE1hc2sgJSV2YWx1ZSUlIHdpdGggYSBiaXRtYXNrIG9mICUlYml0cyUlIG9uZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXNrKF92YWx1ZSwgX2JpdHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IGJpdHMgPSBCaWdJbnQoZ2V0TnVtYmVyKF9iaXRzLCBcImJpdHNcIikpO1xuICAgIHJldHVybiB2YWx1ZSAmICgoQk5fMSA8PCBiaXRzKSAtIEJOXzEpO1xufVxuLyoqXG4gKiAgR2V0cyBhIEJpZ0ludCBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIEJpZ0ludCwgdGhlbiBhbiBBcmd1bWVudEVycm9yIHdpbGwgYmUgdGhyb3duIGZvciAlJW5hbWUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJpZ0ludCh2YWx1ZSwgbmFtZSkge1xuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOiByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbMF0gPT09IFwiLVwiICYmIHZhbHVlWzFdICE9PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLUJpZ0ludCh2YWx1ZS5zdWJzdHJpbmcoMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIEJpZ051bWJlcmlzaCBzdHJpbmc6ICR7ZS5tZXNzYWdlfWAsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQmlnTnVtYmVyaXNoIHZhbHVlXCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKipcbiAqICBSZXR1cm5zICUldmFsdWUlJSBhcyBhIGJpZ2ludCwgdmFsaWRhdGluZyBpdCBpcyB2YWxpZCBhcyBhIGJpZ2ludFxuICogIHZhbHVlIGFuZCB0aGF0IGl0IGlzIHBvc2l0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VWludCh2YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGdldEJpZ0ludCh2YWx1ZSwgbmFtZSk7XG4gICAgYXNzZXJ0KHJlc3VsdCA+PSBCTl8wLCBcInVuc2lnbmVkIHZhbHVlIGNhbm5vdCBiZSBuZWdhdGl2ZVwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICBmYXVsdDogXCJvdmVyZmxvd1wiLCBvcGVyYXRpb246IFwiZ2V0VWludFwiLCB2YWx1ZVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBOaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4vKlxuICogQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnSW50LiBJZiAlJXZhbHVlJSUgaXMgYSBVaW50OEFycmF5LCBpdFxuICogaXMgdHJlYXRlZCBhcyBCaWcgRW5kaWFuIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JpZ0ludCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHgwXCI7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiA+PiA0XTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBOaWJibGVzW3YgJiAweDBmXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRCaWdJbnQodmFsdWUpO1xufVxuLyoqXG4gKiAgR2V0cyBhIC8vbnVtYmVyLy8gZnJvbSAlJXZhbHVlJSUuIElmIGl0IGlzIGFuIGludmFsaWQgdmFsdWUgZm9yXG4gKiAgYSAvL251bWJlci8vLCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TnVtYmVyKHZhbHVlLCBuYW1lKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSwgXCJ1bmRlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXROdW1iZXIoQmlnSW50KHZhbHVlKSwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBudW1lcmljIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBudW1lcmljIHZhbHVlXCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBudW1iZXIuIElmICUldmFsdWUlJSBpcyBhIFVpbnQ4QXJyYXksIGl0XG4gKiAgaXMgdHJlYXRlZCBhcyBCaWcgRW5kaWFuIGRhdGEuIFRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IHNhZmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBnZXROdW1iZXIodG9CaWdJbnQodmFsdWUpKTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZyBFbmRpYW4gaGV4c3RyaW5nLCBvcHRpb25hbGx5IHBhZGRlZCB0b1xuICogICUld2lkdGglJSBieXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmVIZXgoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgaWYgKF93aWR0aCA9PSBudWxsKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgdmFsdWUgaXMgb2YgZXZlbiBsZW5ndGhcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpO1xuICAgICAgICBhc3NlcnQod2lkdGggKiAyID49IHJlc3VsdC5sZW5ndGgsIGB2YWx1ZSBleGNlZWRzIHdpZHRoICgke3dpZHRofSBieXRlcylgLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvQmVIZXhcIixcbiAgICAgICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsXG4gICAgICAgICAgICB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBQYWQgdGhlIHZhbHVlIHRvIHRoZSByZXF1aXJlZCB3aWR0aFxuICAgICAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8ICh3aWR0aCAqIDIpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnIEVuZGlhbiBVaW50OEFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CZUFycmF5KF92YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgaWYgKHZhbHVlID09PSBCTl8wKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXSk7XG4gICAgfVxuICAgIGxldCBoZXggPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgIGhleCA9IFwiMFwiICsgaGV4O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDI7XG4gICAgICAgIHJlc3VsdFtpXSA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyAyKSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbSGV4U3RyaW5nXV0gZm9yICUldmFsdWUlJSBzYWZlIHRvIHVzZSBhcyBhIC8vUXVhbnRpdHkvLy5cbiAqXG4gKiAgQSAvL1F1YW50aXR5Ly8gZG9lcyBub3QgaGF2ZSBhbmQgbGVhZGluZyAwIHZhbHVlcyB1bmxlc3MgdGhlIHZhbHVlIGlzXG4gKiAgdGhlIGxpdGVyYWwgdmFsdWUgYDB4MGAuIFRoaXMgaXMgbW9zdCBjb21tb25seSB1c2VkIGZvciBKU1NPTi1SUENcbiAqICBudW1lcmljIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUXVhbnRpdHkodmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gaGV4bGlmeShpc0J5dGVzTGlrZSh2YWx1ZSkgPyB2YWx1ZSA6IHRvQmVBcnJheSh2YWx1ZSkpLnN1YnN0cmluZygyKTtcbiAgICB3aGlsZSAocmVzdWx0LnN0YXJ0c1dpdGgoXCIwXCIpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgPT09IFwiXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gXCIwXCI7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRocy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/properties.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/properties.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineProperties: () => (/* binding */ defineProperties),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties)\n/* harmony export */ });\n/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\nfunction checkType(value, type, name) {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof (value) === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nasync function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));\n    return results.reduce((accum, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nfunction defineProperties(target, values, types) {\n    for (let key in values) {\n        let value = values[key];\n        const type = (types ? types[key] : null);\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\n//# sourceMappingURL=properties.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcHJvcGVydGllcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSztBQUMzRDtBQUNBLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMENBQTBDO0FBQ3ZGO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvc25hcHAvcGFja2FnZXMvbmV4dGpzL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9wcm9wZXJ0aWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFByb3BlcnR5IGhlbHBlciBmdW5jdGlvbnMuXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6UHJvcGVydGllcyAgW2Fib3V0LXByb3BlcnRpZXNdXG4gKi9cbmZ1bmN0aW9uIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSwgbmFtZSkge1xuICAgIGNvbnN0IHR5cGVzID0gdHlwZS5zcGxpdChcInxcIikubWFwKHQgPT4gdC50cmltKCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYW55XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaW52YWxpZCB2YWx1ZSBmb3IgdHlwZSAke3R5cGV9YCk7XG4gICAgZXJyb3IuY29kZSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xuICAgIGVycm9yLmFyZ3VtZW50ID0gYHZhbHVlLiR7bmFtZX1gO1xuICAgIGVycm9yLnZhbHVlID0gdmFsdWU7XG4gICAgdGhyb3cgZXJyb3I7XG59XG4vKipcbiAqICBSZXNvbHZlcyB0byBhIG5ldyBvYmplY3QgdGhhdCBpcyBhIGNvcHkgb2YgJSV2YWx1ZSUlLCBidXQgd2l0aCBhbGxcbiAqICB2YWx1ZXMgcmVzb2x2ZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlUHJvcGVydGllcyh2YWx1ZSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGtleXMubWFwKChrKSA9PiBQcm9taXNlLnJlc29sdmUodmFsdWVba10pKSk7XG4gICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChhY2N1bSwgdiwgaW5kZXgpID0+IHtcbiAgICAgICAgYWNjdW1ba2V5c1tpbmRleF1dID0gdjtcbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogIEFzc2lnbnMgdGhlICUldmFsdWVzJSUgdG8gJSV0YXJnZXQlJSBhcyByZWFkLW9ubHkgdmFsdWVzLlxuICpcbiAqICBJdCAlJXR5cGVzJSUgaXMgc3BlY2lmaWVkLCB0aGUgdmFsdWVzIGFyZSBjaGVja2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHZhbHVlcywgdHlwZXMpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgICAgICBjb25zdCB0eXBlID0gKHR5cGVzID8gdHlwZXNba2V5XSA6IG51bGwpO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgY2hlY2tUeXBlKHZhbHVlLCB0eXBlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZSwgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnRpZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/units.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/units.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatUnits: () => (/* binding */ formatUnits),\n/* harmony export */   parseEther: () => (/* binding */ parseEther),\n/* harmony export */   parseUnits: () => (/* binding */ parseUnits)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fixednumber.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */\n\n\n\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */\nfunction formatUnits(value, unit) {\n    let decimals = 18;\n    if (typeof (unit) === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    }\n    else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();\n}\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */\nfunction parseUnits(value, unit) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (value) === \"string\", \"value must be a string\", \"value\", value);\n    let decimals = 18;\n    if (typeof (unit) === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    }\n    else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromString(value, { decimals, width: 512 }).value;\n}\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */\nfunction formatEther(wei) {\n    return formatUnits(wei, 18);\n}\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */\nfunction parseEther(ether) {\n    return parseUnits(ether, 18);\n}\n//# sourceMappingURL=units.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdW5pdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QztBQUNFO0FBQ1I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBUztBQUM1QjtBQUNBLFdBQVcsd0RBQVcsOEJBQThCLHNCQUFzQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksMERBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQVM7QUFDNUI7QUFDQSxXQUFXLHdEQUFXLHFCQUFxQixzQkFBc0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9zbmFwcC9wYWNrYWdlcy9uZXh0anMvbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3VuaXRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIE1vc3QgaW50ZXJhY3Rpb25zIHdpdGggRXRoZXJldW0gcmVxdWlyZXMgaW50ZWdlciB2YWx1ZXMsIHdoaWNoIHVzZVxuICogIHRoZSBzbWFsbGVzdCBtYWduaXR1ZGUgdW5pdC5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgZGVhbGluZyB3aXRoIGRvbGxhcnMgYW5kIGNlbnRzLiBTaW5jZSBkb2xsYXJzXG4gKiAgYXJlIGRpdmlzaWJsZSwgbm9uLWludGVnZXIgdmFsdWVzIGFyZSBwb3NzaWJsZSwgc3VjaCBhcyBgYCQxMC43N2BgLlxuICogIEJ5IHVzaW5nIHRoZSBzbWFsbGVzdCBpbmRpdmlzaWJsZSB1bml0IChpLmUuIGNlbnRzKSwgdGhlIHZhbHVlIGNhblxuICogIGJlIGtlcHQgYXMgdGhlIGludGVnZXIgYGAxMDc3YGAuXG4gKlxuICogIFdoZW4gcmVjZWl2aW5nIGRlY2ltYWwgaW5wdXQgZnJvbSB0aGUgdXNlciAoYXMgYSBkZWNpbWFsIHN0cmluZyksXG4gKiAgdGhlIHZhbHVlIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBhbmQgd2hlbiBzaG93aW5nIGEgdXNlclxuICogIGEgdmFsdWUsIHRoZSBpbnRlZ2VyIHZhbHVlIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYSBkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiAgVGhpcyBjcmVhdGVzIGEgY2xlYXIgZGlzdGluY3Rpb24sIGJldHdlZW4gdmFsdWVzIHRvIGJlIHVzZWQgYnkgY29kZVxuICogIChpbnRlZ2VycykgYW5kIHZhbHVlcyB1c2VkIGZvciBkaXNwbGF5IGxvZ2ljIHRvIHVzZXJzIChkZWNpbWFscykuXG4gKlxuICogIFRoZSBuYXRpdmUgdW5pdCBpbiBFdGhlcmV1bSwgLy9ldGhlci8vIGlzIGRpdmlzaWJsZSB0byAxOCBkZWNpbWFsIHBsYWNlcyxcbiAqICB3aGVyZSBlYWNoIGluZGl2aWR1YWwgdW5pdCBpcyBjYWxsZWQgYSAvL3dlaS8vLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlVuaXQgQ29udmVyc2lvbiAgW2Fib3V0LXVuaXRzXVxuICovXG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgRml4ZWROdW1iZXIgfSBmcm9tIFwiLi9maXhlZG51bWJlci5qc1wiO1xuaW1wb3J0IHsgZ2V0TnVtYmVyIH0gZnJvbSBcIi4vbWF0aHMuanNcIjtcbmNvbnN0IG5hbWVzID0gW1xuICAgIFwid2VpXCIsXG4gICAgXCJrd2VpXCIsXG4gICAgXCJtd2VpXCIsXG4gICAgXCJnd2VpXCIsXG4gICAgXCJzemFib1wiLFxuICAgIFwiZmlubmV5XCIsXG4gICAgXCJldGhlclwiLFxuXTtcbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSBpbnRvIGEgLy9kZWNpbWFsIHN0cmluZy8vLCBhc3N1bWluZyAlJXVuaXQlJSBkZWNpbWFsXG4gKiAgcGxhY2VzLiBUaGUgJSV1bml0JSUgbWF5IGJlIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb3IgdGhlIG5hbWUgb2ZcbiAqICBhIHVuaXQgKGUuZy4gYGBcImd3ZWlcImBgIGZvciA5IGRlY2ltYWwgcGxhY2VzKS5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVbml0cyh2YWx1ZSwgdW5pdCkge1xuICAgIGxldCBkZWNpbWFscyA9IDE4O1xuICAgIGlmICh0eXBlb2YgKHVuaXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPj0gMCwgXCJpbnZhbGlkIHVuaXRcIiwgXCJ1bml0XCIsIHVuaXQpO1xuICAgICAgICBkZWNpbWFscyA9IDMgKiBpbmRleDtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGRlY2ltYWxzID0gZ2V0TnVtYmVyKHVuaXQsIFwidW5pdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZSh2YWx1ZSwgZGVjaW1hbHMsIHsgZGVjaW1hbHMsIHdpZHRoOiA1MTIgfSkudG9TdHJpbmcoKTtcbn1cbi8qKlxuICogIENvbnZlcnRzIHRoZSAvL2RlY2ltYWwgc3RyaW5nLy8gJSV2YWx1ZSUlIHRvIGEgQmlnSW50LCBhc3N1bWluZ1xuICogICUldW5pdCUlIGRlY2ltYWwgcGxhY2VzLiBUaGUgJSV1bml0JSUgbWF5IHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAqICBvciB0aGUgbmFtZSBvZiBhIHVuaXQgKGUuZy4gYGBcImd3ZWlcImBgIGZvciA5IGRlY2ltYWwgcGxhY2VzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVW5pdHModmFsdWUsIHVuaXQpIHtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIGxldCBkZWNpbWFscyA9IDE4O1xuICAgIGlmICh0eXBlb2YgKHVuaXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaW5kZXggPj0gMCwgXCJpbnZhbGlkIHVuaXRcIiwgXCJ1bml0XCIsIHVuaXQpO1xuICAgICAgICBkZWNpbWFscyA9IDMgKiBpbmRleDtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGRlY2ltYWxzID0gZ2V0TnVtYmVyKHVuaXQsIFwidW5pdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodmFsdWUsIHsgZGVjaW1hbHMsIHdpZHRoOiA1MTIgfSkudmFsdWU7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgaW50byBhIC8vZGVjaW1hbCBzdHJpbmcvLyB1c2luZyAxOCBkZWNpbWFsIHBsYWNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEV0aGVyKHdlaSkge1xuICAgIHJldHVybiBmb3JtYXRVbml0cyh3ZWksIDE4KTtcbn1cbi8qKlxuICogIENvbnZlcnRzIHRoZSAvL2RlY2ltYWwgc3RyaW5nLy8gJSVldGhlciUlIHRvIGEgQmlnSW50LCB1c2luZyAxOFxuICogIGRlY2ltYWwgcGxhY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFdGhlcihldGhlcikge1xuICAgIHJldHVybiBwYXJzZVVuaXRzKGV0aGVyLCAxOCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bml0cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/units.js\n");

/***/ })

};
;